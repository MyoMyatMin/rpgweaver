export function isNonEmptyString(value: unknown, min = 1): value is string {
  return typeof value === "string" && value.trim().length >= min;
}

export function sanitizeText(input: string): string {
  return input.replace(/[\u0000-\u001F\u007F]/g, "").trim();
}

export function generateId(prefix = "id"): string {
  const random = Math.random().toString(36).slice(2, 8);
  const timestamp = Date.now().toString(36);
  return `${prefix}_${timestamp}_${random}`;
}

type RateBucket = { count: number; resetAt: number };
const rateMap = new Map<string, RateBucket>();

export function checkRateLimit(
  key: string,
  limit = 20,
  windowMs = 60_000
): {
  allowed: boolean;
  remaining: number;
  resetAt: number;
} {
  const now = Date.now();
  const bucket = rateMap.get(key);
  if (!bucket || bucket.resetAt < now) {
    const fresh: RateBucket = { count: 1, resetAt: now + windowMs };
    rateMap.set(key, fresh);
    return { allowed: true, remaining: limit - 1, resetAt: fresh.resetAt };
  }
  if (bucket.count >= limit) {
    return { allowed: false, remaining: 0, resetAt: bucket.resetAt };
  }
  bucket.count += 1;
  return {
    allowed: true,
    remaining: limit - bucket.count,
    resetAt: bucket.resetAt,
  };
}

export function safeJSON<T = unknown>(value: unknown): T | null {
  try {
    return JSON.parse(String(value)) as T;
  } catch {
    return null;
  }
}

export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      lastError = error;
      if (attempt === maxRetries) break;

      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}

export const exportFormats = {
  json: {
    name: "JSON",
    extension: "json",
    mimeType: "application/json",
    transform: (data: any) => JSON.stringify(data, null, 2),
  },
  unity: {
    name: "Unity C#",
    extension: "cs",
    mimeType: "text/plain",
    transform: (data: any) => generateUnityScript(data),
  },
  unreal: {
    name: "Unreal JSON",
    extension: "json",
    mimeType: "application/json",
    transform: (data: any) => generateUnrealFormat(data),
  },
  markdown: {
    name: "Markdown",
    extension: "md",
    mimeType: "text/markdown",
    transform: (data: any) => generateMarkdown(data),
  },
};

function generateUnityScript(data: any): string {
  if (data.type === "dialogue") {
    return `using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string text;
    public List<DialogueOption> options = new List<DialogueOption>();
}

[System.Serializable]
public class DialogueOption
{
    public string id;
    public string text;
    public string nextId;
    public string consequence;
}

public class ${data.npcName.replace(/\s+/g, "")}Dialogue : MonoBehaviour
{
    public List<DialogueNode> dialogue = new List<DialogueNode>();
    
    void Start()
    {
        ${data.dialogue
          .map(
            (node: any) => `
        var node${node.id} = new DialogueNode
        {
            id = "${node.id}",
            text = "${node.text.replace(/"/g, '\\"')}",
            options = new List<DialogueOption>
            {
                ${node.options
                  .map(
                    (opt: any) => `new DialogueOption
                {
                    id = "${opt.id}",
                    text = "${opt.text.replace(/"/g, '\\"')}",
                    nextId = "${opt.nextId || ""}",
                    consequence = "${opt.consequence || ""}"
                }`
                  )
                  .join(",\n                ")}
            }
        };
        dialogue.Add(node${node.id});`
          )
          .join("\n")}
    }
}`;
  }
  return "// Unity script generation not implemented for this type";
}

function generateUnrealFormat(data: any): string {
  return JSON.stringify(
    {
      type: data.type,
      data: data,
      unrealFormat: true,
      timestamp: new Date().toISOString(),
    },
    null,
    2
  );
}

function generateMarkdown(data: any): string {
  if (data.type === "dialogue") {
    return `# ${data.npcName} - Dialogue Tree

**Personality:** ${data.metadata.personality}  
**Mood:** ${data.metadata.mood}  
**Difficulty:** ${data.metadata.difficulty}

## Dialogue Flow

${data.dialogue
  .map(
    (node: any) => `
### ${node.id}: ${node.text}

${node.options
  .map(
    (opt: any) =>
      `- **${opt.text}**${opt.nextId ? ` â†’ ${opt.nextId}` : ""}${
        opt.consequence ? ` (${opt.consequence})` : ""
      }`
  )
  .join("\n")}
`
  )
  .join("\n")}

---
*Generated by RPGWeaver*`;
  }
  return `# ${data.title}

**Location:** ${data.location || "Various"}  
**Duration:** ${data.estimatedDuration}  
**Difficulty:** ${data.difficulty}

## Description
${data.description}

## Objectives
${data.objectives
  .map(
    (obj: any) =>
      `- ${obj.description} (${obj.type})${
        obj.reward ? ` - Reward: ${obj.reward}` : ""
      }`
  )
  .join("\n")}

## Rewards
- Experience: ${data.rewards.experience}
- Gold: ${data.rewards.gold}
${data.rewards.items ? `- Items: ${data.rewards.items.join(", ")}` : ""}

---
*Generated by RPGWeaver*`;
}
